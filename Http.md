## HTTP网络通信协议

TIP/IP：传输控制协议/网际协议 有很多子协议 http ftp https

HTTP：超文本传输协议 简单说就是传输html数据的，HTTP协议是无连接，无状态的，客户端发出请求，连接服务器，得到响应，立即断开。

请求request-响应response：必须由客户端主动发出请求，服务器才能产生响应，一般来说，请求是客户端向服务器端发送数据，而响应是服务器端向客户端发送数据

如果请求的是一个静态资源，服务端会直接响应数据到客户端，如果请求的是一个动态资源，比如java,php,asp，服务器端会先在服务器端执行完毕这些动态内容，然后把执行的结果响应到客户端。

### HTTP请求的三部分组成：

请求行：请求方法（GET POST PUT DELETE）请求的URI 协议和版本 例如http1.1

消息报头：客户端的一些相关信息，例如语言，浏览器，操作系统，压缩方式......

请求正文：GET请求没有请求正文，POST的请求正文存储了发送的数据

### 响应状态码：

200 请求响应

304 从浏览器本地缓存读取数据 (Last Modified)

404 资源找不到

405 无法请求对应的get和post处理程序

429 limit

401 unthrization

403 forbidden

500 服务器程序运行错误

301 永久重定向

302 暂时重定向

### 增删改查的四大操作（CRUD）：restful风格

GET 查询

POST 增加

PUT 修改

DELETE 删除

### WebSocket

WebSocket是一种在单个TCP连接上进行全双工通信的协议。它被设计用于替代传统的HTTP请求/响应模型，以实现更高效、实时的通信。WebSocket使得服务器和客户端可以在建立连接后，双向发送数据，而无需每次发送数据前进行握手，这大大提高了数据传输的效率和速度。

#### WebSocket与HTTP的区别

- **连接方式**：HTTP是基于请求/响应的模型，每次通信都需要建立新的连接（无状态的交互），而WebSocket在连接建立后，可以持续进行双向通信。
- **数据传输**：HTTP传输数据时，需要封装成HTTP请求或响应，包含额外的头部信息，而WebSocket传输的数据更轻量(WebSocket 消息头较小)，没有HTTP头部的开销。
- **实时性**：由于WebSocket的持续连接特性，它能够实现真正的实时通信，而HTTP则需要轮询或长轮询来模拟实时性，效率较低。
- **安全性**：HTTP 可以通过 HTTPS 提供加密传输，确保数据的安全性。WebSocket 可以通过 WSS（WebSocket Secure）提供加密传输，确保数据的安全性。

#### WebSocket的工作原理

WebSocket的工作流程如下：

1. **握手**：客户端通过HTTP发起一个WebSocket连接请求，服务器响应并完成握手过程。
2. **连接建立**：握手成功后，客户端和服务器之间的连接建立，此时可以开始双向通信。
3. **数据传输**：客户端和服务器可以发送任意类型的数据，包括文本和二进制数据。
4. **关闭连接**：任何一方都可以发送关闭帧来关闭连接，另一方接收到关闭帧后，会进行相应的处理并关闭连接。

#### WebSocket 升级握手过程

1. **客户端发送升级请求**
2. **服务器响应升级请求**
3. **连接升级为 WebSocket**

##### 1. 客户端发送升级请求

客户端通过发送一个 HTTP 请求来请求将连接升级为 WebSocket 协议。这个请求包含了一些特定的头部信息，用于标识这是一个 WebSocket 升级请求。

**请求头部**

- `Upgrade: websocket` — 表示请求将连接升级为 WebSocket 协议。
- `Connection: Upgrade` — 表示这是一个升级请求。
- `Sec-WebSocket-Key` — 一个由客户端生成的 Base64 编码的随机字符串，用于验证握手过程。
- `Sec-WebSocket-Version` — 客户端支持的 WebSocket 协议版本，通常是 13。
- `Sec-WebSocket-Protocol`（可选）— 客户端支持的子协议列表。

##### 2. 服务器响应升级请求

服务器收到客户端的升级请求后，会验证请求的合法性，并生成一个响应。如果验证成功，服务器会发送一个 `101 Switching Protocols` 状态码的响应，表示连接已经成功升级为 WebSocket 协议。

**响应头部**

- `Upgrade: websocket` — 确认连接已升级为 WebSocket 协议。
- `Connection: Upgrade` — 确认这是一个升级请求。
- `Sec-WebSocket-Accept` — 服务器根据客户端提供的 `Sec-WebSocket-Key` 计算出的一个 Base64 编码的字符串，用于验证握手过程。
- `Sec-WebSocket-Protocol`（可选）— 服务器选择的子协议。

#### 加密

使用 WSS (WebSocket Secure)：WSS 是基于 TLS/SSL 的 WebSocket 协议，确保数据在传输过程中加密。客户端和服务器之间的所有通信都经过加密，防止数据被窃听或篡改。


## 协议

### UDP
UDP 是 User Datagram Protocol 的简称，中文名是用户数据报协议，是 OSI（Open System Interconnection，开放式系统互联）参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。

在网络中它与 TCP 协议一样用于处理数据包，是一种无连接的协议。在 OSI 模型中，在第四层——传输层，处于 IP 协议的上一层。UDP 有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。UDP 用来支持那些需要在计算机之间传输数据的网络应用。包括网络视频会议系统在内的众多的客户/服务器模式的网络应用都需要使用 UDP 协议。

### TCP（传输控制协议）和 UDP 的区别
- **连接方式**：TCP 是面向连接的协议，需要在通信前建立连接，而 UDP 是无连接的协议，可以直接发送数据包。
- **可靠性**：TCP 保证传输数据的可靠性，能够保证所有数据到达目的地且顺序正确；UDP 不保证传输数据的可靠性，可能会出现数据丢失或乱序等问题。
- **开销**：TCP 在传输过程中要维护连接状态、进行流量控制、拥塞控制等操作，因此开销较大；UDP 没有这些机制，传输开销较小。
- **速度**：由于 TCP 需要保证数据的可靠性，因此传输速度可能会受到一定的影响；UDP 没有这个限制，传输速度快。
- **适用场景**：TCP 适用于对可靠性要求较高的应用场景，如文件传输、邮件传输等；而 UDP 适用于实时性要求较高的应用场景，如语音、视频、游戏等。

### TCP
（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。在简化的计算机网络 OSI 模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP）是同一层内另一个重要的传输协议。在因特网协议族（Internet protocol suite）中，TCP 层是位于 IP 层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是 IP 层不提供这样的流机制，而是提供不可靠的包交换。

应用层向 TCP 层发送用于网间传输的、用 8 位字节表示的数据流，然后 TCP 把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后 TCP 把结果包传给 IP 层，由它来通过网络将包传送给接收端实体的 TCP 层。TCP 为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP 用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验。

### TCP 相比 UDP 为什么是可靠的
1. **确认和重传机制**
   - 建立连接时三次握手同步双方的“序列号 + 确认号 + 窗口大小信息”，是确认重传、流控的基础。
   - 传输过程中，如果 Checksum 校验失败、丢包或延时，发送端重传。

2. **数据排序**
   - TCP 有专门的序列号 SN 字段，可提供数据 re-order。

3. **流量控制**
   - 窗口和计时器的使用。TCP 窗口中会指明双方能够发送接收的最大数据量。

4. **拥塞控制**
   - TCP 的拥塞控制由 4 个核心算法组成：
     - “慢启动”（Slow Start）
     - “拥塞避免”（Congestion Avoidance）
     - “快速重传”（Fast Retransmit）
     - “快速恢复”（Fast Recovery）

### TCP 拥塞
主要原因是网络带宽限制、缓冲区溢出、慢启动、拥塞避免、快重传和快恢复机制，以及拥塞控制算法的选择。

### IP
[参考链接](https://draveness.me/whys-the-design-ipv6-replacing-ipv4/)

### TCP/IP 协议
TCP/IP 协议（Transmission Control Protocol/Internet Protocol）是互联网的基本协议，也是国际互联网络的基础。它不仅仅指的是 TCP 和 IP 这两个协议，而是一个由多个网络协议组成的协议族，包括 FTP、SMTP、UDP、ICMP、ARP 等协议。TCP/IP 协议定义了计算机操作系统如何连入互联网，以及数据传输的标准。

### TCP/IP 协议的层级结构
TCP/IP 协议采用四层的层级结构，每一层都呼叫它的下一层所提供的服务来完成自己的需求：

1. **链路层**：处理与电缆或其他传输媒介的物理接口细节。
2. **网络层**：处理分组的选路和转发，主要包括 IP 协议。
3. **传输层**：提供端到端的通信控制，主要包括 TCP 协议和 UDP 协议。
4. **应用层**：提供各种应用服务，如 HTTP 协议、FTP 协议、SMTP 协议等。

### OSI 七层模型
OSI（Open Systems Interconnection）模型是由国际标准化组织（ISO）提出的理论框架，旨在为网络通信提供一个标准化的参考模型。OSI 模型将网络通信功能划分为七个层次，每一层都有明确的功能和职责：

1. 物理层（Physical Layer）
   - 功能：定义了网络传输媒介的技术规范，包括电压、频率、信号强度、电缆接口、传输速率等。
   - 示例：同轴电缆、光纤、双绞线。

2. 数据链路层（Data Link Layer）
   - 功能：负责在物理层提供的服务之上建立逻辑链路，提供可靠的数据传输，包括帧同步、错误检测和纠正等。
   - 示例：以太网、PPP（点对点协议）。

3. 网络层（Network Layer）
   - 功能：负责路由选择和寻址，确保数据包从源地址正确地传输到目的地址。
   - 示例：IP 协议、ICMP 协议、ARP 协议。

4. 传输层（Transport Layer）
   - 功能：负责端到端的数据传输，提供可靠的数据传输服务。
   - 示例：TCP（传输控制协议）、UDP（用户数据报协议）。

5. 会话层（Session Layer）
   - 功能：负责建立、管理和终止会话，提供会话管理和同步功能。
   - 示例：RPC（远程过程调用）、NFS（网络文件系统）。

6. 表示层（Presentation Layer）
   - 功能：负责数据的表示形式和加密解密，处理数据编码、压缩、加密等。
   - 示例：JPEG、MPEG、ASCII 等。

7. 应用层（Application Layer）
   - 功能：提供应用程序之间的通信，为用户提供网络服务。
   - 示例：HTTP、FTP、SMTP、DNS 等。

### TCP/IP 四层模型
TCP/IP（Transmission Control Protocol/Internet Protocol）模型是实际互联网使用的模型，它将网络通信功能划分为四个层次：

1. **应用层（Application Layer）**
   - 功能：与 OSI 模型的应用层和表示层对应，提供应用程序之间的通信。
   - 示例：HTTP、FTP、SMTP、DNS 等。

2. **传输层（Transport Layer）**
   - 功能：与 OSI 模型的传输层对应，负责端到端的数据传输。
   - 示例：TCP、UDP。

3. **网络层（Internet Layer）**
   - 功能：与 OSI 模型的网络层对应，负责路由选择和寻址。
   - 示例：IP 协议、ICMP 协议、ARP 协议。

4. **网络接口层（Network Interface Layer）**
   - 功能：与 OSI 模型的数据链路层和物理层对应，负责物理介质上的数据传输。
   - 示例：以太网、PPP、Wi-Fi。

### 对比
1. **层数不同**
   - OSI 七层模型：分为七层，每一层都有明确的功能和职责。
   - TCP/IP 四层模型：分为四层，简化了 OSI 模型中的某些层次。

2. **层次划分**
   - OSI 模型：更加细致地划分了网络通信的功能，例如会话层和表示层。
   - TCP/IP 模型：将 OSI 模型中的会话层和表示层合并到应用层中。

3. **实际应用**
   - OSI 模型：主要用于理论研究和教学，提供了详细的网络通信层次结构。
   - TCP/IP 模型：实际互联网的标准模型，更接近实际应用中的层次划分。

### VPN
Virtual Private Network 虚拟专用网络的功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN 网关通过对数据包的加密和数据包目标地址的转换实现远程访问。VPN 有多种分类方式，主要是按协议进行分类。VPN 可通过服务器、硬件、软件等多种方式实现。

### SOAP
Simple Object Access Protocol 简单对象访问协议是交换数据的一种协议规范。基于 XML 的协议。

### WebService 三要素
- **SOAP**：用来描述传递信息的格式。
- **WSDL（Web Services Description Language）**：用来描述如何访问具体的接口。
- **UDDI（Universal Description Discovery and Integration）**：用来管理、分发、查询 WebService。

SOAP 可以和现存的许多因特网协议和格式结合使用，包括 HTTP、SMTP、MIME。它还支持从消息系统到远程过程调用（RPC）等大量的应用程序。SOAP 使用基于 XML 的数据结构和 HTTP 的组合定义了一个标准的方法来使用 Internet 上各种不同操作环境中的分布式对象。

### DNS
Domain Name System

1. 查找本地 DNS 解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。
2. 在浏览器中输入 www.qq.com 域名，操作系统会先检查自己本地的 hosts 文件是否有这个网址映射关系，如果有，就先调用这个 IP 地址映射，完成域名解析。
3. 如果 hosts 里没有这个域名的映射，且本地 DNS 解析器缓存也没有相应的网址映射关系，首先会找 TCP/IP 参数中设置的首选 DNS 服务器，在此我们叫它本地 DNS 服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。
4. 如果要查询的域名不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析，此解析不具有权威性。
5. 如果本地 DNS 服务器本地区域文件与缓存解析都失效，则根据本地 DNS 服务器的设置（是否设置转发器）进行查询。如果未用转发模式，本地 DNS 就把请求发至 13 台根 DNS，根 DNS 服务器收到请求后会判断这个域名（.com）是谁来授权管理，并会返回一个负责该顶级域名服务器的一个 IP。本地 DNS 服务器收到 IP 信息后，将会联系负责 .com 域的这台服务器。这台负责 .com 域的服务器收到请求后，如果自己无法解析，它就会找一个管理 .com 域的下一级 DNS 服务器地址（如 qq.com）给本地 DNS 服务器。当本地 DNS 服务器收到这个地址后，就会找 qq.com 域服务器，重复上面的动作，进行查询，直至找到 www.qq.com 主机。
6. 如果用的是转发模式，此 DNS 服务器就会把请求转发至上一级 DNS 服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根 DNS 或把转请求转至上上级，以此循环。不管是本地 DNS 服务器用转发，还是根提示，最后都是把结果返回给本地 DNS 服务器，由此 DNS 服务器再返回给客户机。

从客户端到本地 DNS 服务器是属于递归查询，而 DNS 服务器之间就是的交互查询就是迭代查询。

### DNS 只能拿到 IP，是如何将 IP 转为 MAC 地址
将 IP 地址解析为 MAC（媒体访问控制地址）地址的过程是由数据链路层的 ARP（Address Resolution Protocol）完成。

通过 ARP 协议，ARP 维护一个本地的高速缓存表，里面有 IP 到 MAC 的映射，若没有则广播消息查找。

- **发送 ARP 请求**：
  - 客户端需要将数据包发送到目标 IP 地址，但不知道该 IP 地址对应的 MAC 地址。
  - 客户端在本地网络中广播一个 ARP 请求，询问谁拥有目标 IP 地址。
  - ARP 请求包含客户端的 MAC 地址和 IP 地址，以及目标 IP 地址。

- **接收 ARP 请求**：
  - 所有在同一局域网内的设备都会接收到这个广播请求。
  - 如果某个设备的 IP 地址是目标 IP，它会回复一个 ARP 应答。

- **发送 ARP 应答**：
  - 拥有目标 IP 地址的设备向客户端发送一个 ARP 应答。
  - ARP 应答包含目标设备的 MAC 地址。

- **更新 ARP 缓存**：
  - 客户端收到 ARP 应答后，将 IP 地址和 MAC 地址的对应关系缓存起来，以便将来使用。

### 三次握手
三次握手是指建立 TCP 连接时，需要客户端和服务器总共需要发送三个包。

1. 作用是为了确认双方的接收能力和发送能力是否正常。
2. 防止服务器端因接收了早已失效的连接请求报文，从而一直等待客户端请求。

- **第一次握手（SYN）**：
  - 客户端向服务器发送一个带有 SYN（Synchronize）标志的数据包，并选择一个初始序列号（Sequence Number，简称 Seq），表示客户端希望开始建立连接。
  - 例如，客户端发送一个 SYN 数据包，其中包含序列号 X。

- **第二次握手（SYN+ACK）**：
  - 服务器收到客户端的 SYN 数据包后，确认收到，并向客户端发送一个带有 SYN 和 ACK（Acknowledgment）标志的数据包。
  - 服务器选择自己的初始序列号 Y，并确认客户端的序列号 X+1（表明收到了客户端的序列号 X）。
  - 例如，服务器发送一个 SYN+ACK 数据包，其中包含序列号 Y 和确认号 X+1。

- **第三次握手（ACK）**：
  - 客户端收到服务器的 SYN+ACK 数据包后，确认收到，并向服务器发送一个带有 ACK 标志的数据包。
  - 客户端确认服务器的序列号 Y+1（表明收到了服务器的序列号 Y）。
  - 例如，客户端发送一个 ACK 数据包，其中包含确认号 Y+1。

### 挥手为什么需要四次
1. **双方向确认**：
   - 四次挥手过程中，连接的双方都需要确认对方的数据传输已经结束。主动关闭方发送 FIN 表示不再发送数据，而被动关闭方也需要发送 FIN 表示自己的数据传输也已完成。

2. **防止丢失确认**：
   - 如果只有三次挥手，那么在被动关闭方发送 FIN 后，如果 ACK 数据包丢失，主动关闭方无法知道被动关闭方是否收到了 FIN。因此，需要第四次挥手来确认被动关闭方的 FIN 已经被主动关闭方收到。

