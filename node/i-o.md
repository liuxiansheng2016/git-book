# I/O

### **Node.js 如何实现非阻塞 I/O？**

Node.js 通过 **事件驱动（Event-Driven）** 和 **非阻塞 I/O（Non-blocking I/O）** 机制，实现了高并发处理能力，使其非常适合 I/O 密集型应用（如 Web 服务器、数据库操作、文件读写等）。

1. **单线程 + 事件循环（Event Loop）**
   * Node.js 使用 **单线程** 处理所有请求，避免了多线程编程的复杂性。
   * 采用 **事件驱动** 方式，将 I/O 操作交给底层 **操作系统内核** 处理，等待数据准备好后，再通过 **回调函数** 或 **Promise** 继续执行代码。
2. **基于 libuv 实现异步 I/O**
   * `libuv` 是 Node.js 的底层库，负责处理 **异步 I/O 任务（如文件读写、网络请求、数据库操作）**。
   * `libuv` 在 **内部使用线程池（Thread Pool）**，让 I/O 操作交给 **系统内核** 处理，而不会阻塞主线程。
3. **使用回调、Promise、async/await**
   * 传统的 **同步 I/O** 代码会阻塞线程，而 **Node.js 通过回调（Callback）、Promise、async/await** 方式，在 I/O 操作完成后继续执行代码，而不会阻塞整个程序。

***

### 同步和异步

同步：当调用一个同步函数时，调用者必须等待该函数返回后才能继续执行后续的操作。这意味着如果一个同步操作耗时较长，比如文件读取或网络请求，那么整个应用程序将会被阻塞，直到该操作完成

异步：相反，异步操作一旦发起就会立即返回，允许调用者继续执行后续的任务。当异步操作完成时，它会通过某种机制（如事件、回调函数等）通知调用者，并传递必要的结果信息。这种方式使得 Node.js 能够高效地处理高并发场景，因为它不会因为等待某个长时间运行的任务而停止响应新的请求

**异步流程控制的方法**

* 回调函数（Callbacks）
* 事件监听器（Event Listeners）
* Promises 提供了一种更现代且优雅的方式来处理异步操作。它们代表了异步操作最终的状态变化（成功或失败）
* Async/Await
* 流（Streams）对于需要逐步处理大量数据的情况，Node.js 提供了流的概念。流是一种抽象接口，用于处理流动的数据。你可以监听流的不同事件（如 data、end、error）来逐步处理数据或响应流的状态变化
