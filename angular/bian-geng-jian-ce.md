---
description: https://xie.infoq.cn/article/dda6d6d0004d7b22a21264d04
---

# 变更检测

## 脏检查

在一些前端框架（如早期的 AngularJS）中，脏检查用于实现数据绑定和视图更新。当数据模型发生变化时，框架会通过脏检查机制检测到这些变化，并自动更新与之绑定的视图。

1. **记录初始状态**：在某个时刻，记录下数据的当前状态，这通常是一个数据快照。
2. **触发检查**：在特定的条件下（如用户交互事件、定时任务等），启动脏检查过程。
3. **比较状态**：将当前数据状态与之前记录的初始状态进行比较。
4. **处理变化**：如果发现数据状态发生了变化（即变 “脏”），则执行相应的处理逻辑，如更新视图、保存数据等。

## Angular 检测流程

\
Angular 采用自上而下的深度优先遍历策略进行变更检测：

1. **从根组件开始**：变更检测从应用的根组件启动。
2. **遍历子组件**：依次检查根组件及其所有子组件。
3. **检查数据绑定**：查看组件模板中的数据绑定表达式，如插值表达式 `{{ property }}`、属性绑定 `[attr]="property"` 等，对比数据模型和视图的状态是否一致。
4. **传播变更**：如果发现某个组件的数据发生变化，更新该组件的视图，并继续检查其子组件，确保变更能正确传播。

## 默认策略 (`ChangeDetectionStrategy.Default`)

在使用默认策略时，<mark style="color:red;">Angular 的变更检测非常敏感且全面</mark>。每当有以下事件发生时，都会触发整个组件树的变更检测：

* 用户交互（如点击、输入等）。
* 浏览器事件（如 `setTimeout`, `setInterval` 等异步操作）。
* HTTP 请求或其他网络活动（如通过 Angular 的 `HttpClient` 发起的请求）。
* 任何其他异步任务，比如 Promises 或者 Observables 的完成&#x20;

这意味着，即使某个组件的状态没有发生变化，只要上述任意一个事件发生，Angular 都会检查该组件及其所有子组件是否有需要更新的内容。

## OnPush 策略 (`ChangeDetectionStrategy.OnPush`)

相比之下，`OnPush` 策略提供了一种更加高效的变更检测方式。它<mark style="color:red;">仅在特定条件下才会触发组件的变更检测</mark>，这使得它可以显著减少不必要的检查次数。以下是 `OnPush` 策略下变更检测被触发的情况：

1. **输入属性变化**：当组件的 `@Input()` 装饰器接收的新值与旧值相比发生了变化时，变更检测将被触发。这里需要注意的是，对于引用类型的数据（如对象或数组），只有当它们的引用地址改变时，Angular 才认为这些数据发生了变化
2. **DOM 事件**：如果组件本身或者其子组件触发了 DOM 事件（例如点击事件），也会触发变更检测
3. **Observable 触发**：如果组件中绑定了 Observable，并且这个 Observable 发出了新的值，则会触发变更检测
4. **手动调用变更检测**：开发者可以通过调用 `ChangeDetectorRef` 提供的方法来手动触发变更检测，如 `markForCheck()` 方法可以在当前组件以及其祖先组件上标记为“脏”，从而强制执行变更检测；而 `detectChanges()` 方法则直接对当前组件和它的子组件执行一次变更检测

&#x20;使用 `HttpClient` 进行 HTTP 请求，并且你将请求的结果通过 <mark style="color:red;">`async`</mark> <mark style="color:red;"></mark><mark style="color:red;">管道绑定到了模板上，那么每当有新的数据到达时，Angular 都会自动进行变更检测并更新视图</mark>。

需要注意的是在 `OnPush` 策略中，以下操作不会触发变化检测：

* setTimeout()
* setInterval()
* Promise.resolve().then()
* this.http.get('...').subscribe()

## ChangeDetectorRef&#x20;

是 Angular 中一个非常重要的类，它提供了对组件变更检测机制的细粒度控制。

ChangeDetectorRef 提供了几种方法来管理变更检测过程：

1. markForCheck()：当使用 OnPush 策略时，如果组件的输入属性没有发生变化，但你仍然希望该组件及其祖先组件被检查，则可以调用此方法。这将使得即使没有触发器，也会检查该组件（<mark style="color:red;">markForCheck() 不会立即触发变更检测，而是将当前组件及所有父组件标记为需要检测的状态</mark>。这意味着如果一个组件或其某个祖先组件使用了 OnPush 策略，调用 markForCheck() 后，Angular 将会在下一次全局变更检测时重新评估这些组件的状态，）
2. detach()：从变更检测树中移除当前组件的变更检测器。这意味着该组件及其子组件将不再执行变更检测，直到重新附加为止。这对于避免不必要的变更检测非常有用，特别是在处理大量数据或复杂计算时
3. reattach()：将之前分离出去的变更检测器重新添加回变更检测树中，从而使组件能够再次参与变更检测流程。通常与 detach() 一起使用，以实现局部变更检测8。
4. detectChanges()：强制立即对该组件及其所有子组件执行一次变更检测。这对于确保视图及时反映最新的数据状态特别有帮助，尤其是在异步操作完成之后1。
5. checkNoChanges()：用于调试目的，检查是否存在未预期的状态更改。它会抛出错误，如果发现任何脏值（即未经处理的数据变更）。这个方法在开发阶段很有用，但在生产环境中应该谨慎使用，因为它可能会导致性能问题8
