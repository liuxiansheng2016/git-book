# 浏览器基础

### 浏览器进程与线程：

[https://zhuanlan.zhihu.com/p/133239925](https://zhuanlan.zhihu.com/p/133239925)\
\
进程是资源分配和独立运行的基本单位，而线程是进程中的执行单元。

进程之间独立运行，线程共享进程的资源。

线程共享相同的地址空间，因此线程间的通信相对容易。                                                                                                          &#x20;

进程切换的开销较大，线程切换的开销相对较小。

进程之间需要通过进程间通信（IPC）来进行数据交换，线程之间可以直接访问共享的数据。

### 浏览器的多进程架构

1      浏览器进程 要负责界面显示、用户交互、子进程管理，同时提供存储等功能

2       渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页

3       插件进程： 网页使用的插件

4       GPU进程： 负责整个应用程序的GPU任务

5       网络进程

优点： 安全 快速，容错性

### 渲染流程：

**解析HTML构建DOM树**：

**解析CSS构建CSSOM树**：

**构建渲染树**：一旦DOM和CSSOM都准备好了，浏览器就会结合两者来构建渲染树。渲染树只包含可见的节点及其对应的样式信息，例如被设置了`display: none;`的元素不会出现在渲染树中

**布局（Layout/Reflow）**：在构建好渲染树之后，浏览器会计算每个可见元素的位置和尺寸，这个过程称为布局或重排。这决定了每个元素在视口内的确切位置。任何影响几何结构的变化都会触发重新布局  (分层)

**绘制（Painting）**：完成布局后，浏览器开始绘制，即填充每个元素的颜色、图像、边框等属性。这一阶段生成的是位图。值得注意的是，如果渲染树发生了改变，则渲染器会触发重绘（Repaint）和重排（Reflow），其中重排的成本通常比重绘要高得多

**光栅化（Rasterization）**：通过解析、布局和绘制过程，浏览器获得了文档的结构、每个元素的样式、绘制顺序等信息。接下来，这些信息会被转换为屏幕上的像素，这个过程被称为光栅化。光栅化可以被GPU加速，光栅化后的位图会被存储在GPU内存中

**合成（Compositing）**：现代浏览器通常使用合成的方式，将页面的各个部分分成若干层，分别对其进行栅格化（将它们分割成了不同的瓦片）。然后，这些图层会在GPU上进行合成，最终显示在屏幕上

#### 重绘触发

**绘制（Painting）**：**光栅化（Rasterization）**：**合成（Compositing）**

#### 回流触发

**布局 绘制（Painting）**：**光栅化（Rasterization）**：**合成（Compositing）**

#### 重绘和回流 [https://www.jianshu.com/p/e081f9aa03fb](https://www.jianshu.com/p/e081f9aa03fb)

·        当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。

·        当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow）

### 浏览器的结构：

用户界面

浏览器引擎

渲染引擎

Js 解释器

网络

用户界面后端

数据存储

{% embed url="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" %}

**JS 引擎主要由两部分组成：**

* **内存堆**\
  内存堆是用于动态分配内存的区域，所有对象、数组和函数等数据都存储在这里。当我们创建变量或对象时，这些数据会分配到内存堆中。
* **调用栈**\
  调用栈是一个数据结构，用于记录程序中正在执行的函数调用。JavaScript 的执行环境只有一个调用栈，这也意味着 JavaScript 是单线程语言，同一时间只能执行一个任务。调用栈按顺序记录当前代码执行的位置，当一个函数被调用时，它会被压入调用栈，函数执行完毕后，再从栈中弹出。

### 垃圾回收的基本原理



**标记-清除（Mark and Sweep）：**

标记：从根对象（如全局变量、栈中的局部变量等）出发，递归地遍历所有可达对象，并标记这些对象。

清除：扫描整个堆内存，释放未被标记的对象所占用的内存。

**引用计数（Reference Counting）：**

每个对象都有一个引用计数器，每当有一个新的引用指向该对象时，计数器加1；每当有一个引用被移除时，计数器减1。

当引用计数器为0时，对象被释放。

缺点：无法处理循环引用的问题。

**分代收集（Generational Collection）：**

将堆内存分为不同的代（如新生代和老年代），不同代的垃圾回收策略不同。

新生代：频繁进行小规模的垃圾回收，因为新分配的对象往往生命周期较短。

老年代：较少进行大规模的垃圾回收，因为老对象往往生命周期较长。

**标记-压缩**

1. **标记**：与标记-清除相同。
2. **压缩**：将存活的对象移动到连续的内存区域，以减少内存碎片。

**垃圾回收的挑战**

1. **性能开销**：垃圾回收过程会消耗 CPU 和内存资源，可能导致应用程序短暂的停顿。
2. **内存碎片**：频繁的垃圾回收可能导致内存碎片，影响内存分配效率。
3. **循环引用**：引用计数机制无法处理循环引用的问题，需要额外的机制来检测和处理。

### 同步任务 和异步任务

<figure><img src=".gitbook/assets/image (10).png" alt=""><figcaption><p><br></p></figcaption></figure>

1. 在执行过程中，同步和异步任务分别进入不同的执行场所，同步的是进入主线程，异步的进入Event Table并注册函数
2. 指定的事情完成时，Event Tabel 会将这个函数移入Event Quene
3. &#x20;主线程内的任务执行完毕时为空，会将Event Queue读取对应函数，进入主线程执行
4.  以上过程重复时，就是Event Loop\


    除了广义的同步任务和异步任务之外，JavaScript 将异步任务进一步分为两类：

    * **宏任务（Macro-task）**\
      宏任务包括整个脚本（script 标签中执行的代码）、定时器（setTimeout、setInterval）等。\
      在 Node.js 中，`setImmediate` 的回调也被归为宏任务，它会在当前事件循环的 Check 阶段执行。
    * **微任务（Micro-task）**\
      微任务主要包括 Promise 的 then/catch/finally 回调、MutationObserver，以及在 Node.js 中的 process.nextTick（它有更高的优先级，会在当前执行栈结束后、下一个宏任务之前执行）。

### **解释性语言** 与 **编译型语**

**解释性语言**

* **工作原理**：\
  代码在执行时由解释器逐行读取并即时翻译成机器能够理解的指令，整个过程在运行时完成。
* **优点**：
  * 开发周期较短，调试和测试方便，因为不需要提前编译整个程序。
  * 跨平台性通常较好，只要目标平台有相应的解释器即可运行。
* **缺点**：
  * 执行效率通常比编译型语言低，因为每次运行时都需要即时解释转换。
  * 代码保护性较差，源代码容易被查看和修改。
* **常见语言**：\
  Python、JavaScript、Ruby、PHP 等。

***

### **编译型语言**

* **工作原理**：\
  代码在运行之前经过编译器转换成机器码或中间码（如字节码），生成可执行文件或库，再由系统直接运行。
* **优点**：
  * 执行效率较高，因为编译后的代码可以直接在目标机器上运行，不需要再进行逐行解释。
  * 代码优化可以在编译阶段完成，通常能获得更好的性能。
* **缺点**：
  * 开发周期较长，每次修改后需要重新编译，调试可能不如解释性语言灵活。
  * 跨平台支持需要针对不同平台进行编译。
* **常见语言**：\
  C、C++、Go、Rust，Java（编译为字节码，再由虚拟机解释或即时编译）等。\


### 混合型语言

混合型语言指的是既具备编译型语言的特性，又采用了解释型语言某些机制的语言。这类语言通常将源代码编译成中间代码（例如字节码），然后由虚拟机解释执行或进行即时编译（JIT），从而兼顾了性能和跨平台的优势。

例如：

* **Java**：Java 源代码首先被编译成字节码，然后在 JVM（Java 虚拟机）上运行，JVM 可以对字节码进行即时编译以提升执行速度。
* **C#**：C# 代码编译成中间语言（IL），然后由 .NET CLR（公共语言运行库）执行，也支持 JIT 编译。
* **Python**（部分实现）：一些 Python 实现（例如 PyPy）会对字节码进行即时编译，从而提高执行效率。

***

**总结**

* 解释性语言适合快速开发和原型设计，代码易于调试，但运行效率相对较低。
* 编译型语言则在性能上具有优势，适用于对效率要求较高的应用，但开发周期和调试难度可能会增加
