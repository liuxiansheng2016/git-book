# 浏览器基础

### 浏览器进程与线程：

[https://zhuanlan.zhihu.com/p/133239925](https://zhuanlan.zhihu.com/p/133239925)\
\
进程是资源分配和独立运行的基本单位，而线程是进程中的执行单元。

进程之间独立运行，线程共享进程的资源。

线程共享相同的地址空间，因此线程间的通信相对容易。                                                                                                          &#x20;

进程切换的开销较大，线程切换的开销相对较小。

进程之间需要通过进程间通信（IPC）来进行数据交换，线程之间可以直接访问共享的数据。

### 浏览器的多进程架构

1      浏览器进程 要负责界面显示、用户交互、子进程管理，同时提供存储等功能

2       渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页

3       插件进程： 网页使用的插件

4       GPU进程： 负责整个应用程序的GPU任务

5       网络进程

优点： 安全 快速，容错性

### 渲染流程：

**解析HTML构建DOM树**：

**解析CSS构建CSSOM树**：

**构建渲染树**：一旦DOM和CSSOM都准备好了，浏览器就会结合两者来构建渲染树。渲染树只包含可见的节点及其对应的样式信息，例如被设置了`display: none;`的元素不会出现在渲染树中

**布局（Layout/Reflow）**：在构建好渲染树之后，浏览器会计算每个可见元素的位置和尺寸，这个过程称为布局或重排。这决定了每个元素在视口内的确切位置。任何影响几何结构的变化都会触发重新布局  (分层)

**绘制（Painting）**：完成布局后，浏览器开始绘制，即填充每个元素的颜色、图像、边框等属性。这一阶段生成的是位图。值得注意的是，如果渲染树发生了改变，则渲染器会触发重绘（Repaint）和重排（Reflow），其中重排的成本通常比重绘要高得多

**光栅化（Rasterization）**：通过解析、布局和绘制过程，浏览器获得了文档的结构、每个元素的样式、绘制顺序等信息。接下来，这些信息会被转换为屏幕上的像素，这个过程被称为光栅化。光栅化可以被GPU加速，光栅化后的位图会被存储在GPU内存中

**合成（Compositing）**：现代浏览器通常使用合成的方式，将页面的各个部分分成若干层，分别对其进行栅格化（将它们分割成了不同的瓦片）。然后，这些图层会在GPU上进行合成，最终显示在屏幕上

#### 重绘触发

**绘制（Painting）**：**光栅化（Rasterization）**：**合成（Compositing）**

#### 回流触发

**布局 绘制（Painting）**：**光栅化（Rasterization）**：**合成（Compositing）**

#### 重绘和回流 [https://www.jianshu.com/p/e081f9aa03fb](https://www.jianshu.com/p/e081f9aa03fb)

·        当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。

·        当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow）

### 浏览器的结构：

用户界面

浏览器引擎

渲染引擎

Js 解释器

网络

用户界面后端

数据存储

{% embed url="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/" %}

**JS 引擎主要由两部分组成：**

* **内存堆**\
  内存堆是用于动态分配内存的区域，所有对象、数组和函数等数据都存储在这里。当我们创建变量或对象时，这些数据会分配到内存堆中。
* **调用栈**\
  调用栈是一个数据结构，用于记录程序中正在执行的函数调用。JavaScript 的执行环境只有一个调用栈，这也意味着 JavaScript 是单线程语言，同一时间只能执行一个任务。调用栈按顺序记录当前代码执行的位置，当一个函数被调用时，它会被压入调用栈，函数执行完毕后，再从栈中弹出。

### V8

即时编译（JIT）：V8 在运行时将 JavaScript 代码转换成机器码，而不是字节码。这种方式可以提高执行速度，因为机器码可以直接由处理器执行。

快速执行：由于 V8 在运行时直接生成本地代码，这使得 JavaScript 能够更快地执行。此外，V8 还包括了一个称为“Crankshaft”的优化编译器，它可以进一步优化热点函数，使其执行速度更快。

### 垃圾回收的基本原理



**标记-清除（Mark and Sweep）：**

标记：从根对象（如全局变量、栈中的局部变量等）出发，递归地遍历所有可达对象，并标记这些对象。

清除：扫描整个堆内存，释放未被标记的对象所占用的内存。

**引用计数（Reference Counting）：**

每个对象都有一个引用计数器，每当有一个新的引用指向该对象时，计数器加1；每当有一个引用被移除时，计数器减1。

当引用计数器为0时，对象被释放。

缺点：无法处理循环引用的问题。

**分代收集（Generational Collection）：**

将堆内存分为不同的代（如新生代和老年代），不同代的垃圾回收策略不同。

新生代：频繁进行小规模的垃圾回收，因为新分配的对象往往生命周期较短。

老年代：较少进行大规模的垃圾回收，因为老对象往往生命周期较长。

**标记-压缩**

1. **标记**：与标记-清除相同。
2. **压缩**：将存活的对象移动到连续的内存区域，以减少内存碎片。

**垃圾回收的挑战**

1. **性能开销**：垃圾回收过程会消耗 CPU 和内存资源，可能导致应用程序短暂的停顿。
2. **内存碎片**：频繁的垃圾回收可能导致内存碎片，影响内存分配效率。
3. **循环引用**：引用计数机制无法处理循环引用的问题，需要额外的机制来检测和处理。

### 同步任务 和异步任务

<figure><img src=".gitbook/assets/image (10).png" alt=""><figcaption><p><br></p></figcaption></figure>

1. 在执行过程中，同步和异步任务分别进入不同的执行场所，同步的是进入主线程，异步的进入Event Table并注册函数
2. 指定的事情完成时，Event Tabel 会将这个函数移入Event Quene
3. &#x20;主线程内的任务执行完毕时为空，会将Event Queue读取对应函数，进入主线程执行
4.  以上过程重复时，就是Event Loop\


    除了广义的同步任务和异步任务之外，JavaScript 将异步任务进一步分为两类：

    * **宏任务（Macro-task）**\
      宏任务包括整个脚本（script 标签中执行的代码）、定时器（setTimeout、setInterval）等。\
      在 Node.js 中，`setImmediate` 的回调也被归为宏任务，它会在当前事件循环的 Check 阶段执行。
    * **微任务（Micro-task）**\
      微任务主要包括 Promise 的 then/catch/finally 回调、MutationObserver，以及在 Node.js 中的 process.nextTick（它有更高的优先级，会在当前执行栈结束后、下一个宏任务之前执行）。

### **解释性语言** 与 **编译型语**

**解释性语言**

* **工作原理**：\
  代码在执行时由解释器逐行读取并即时翻译成机器能够理解的指令，整个过程在运行时完成。
* **优点**：
  * 开发周期较短，调试和测试方便，因为不需要提前编译整个程序。
  * 跨平台性通常较好，只要目标平台有相应的解释器即可运行。
* **缺点**：
  * 执行效率通常比编译型语言低，因为每次运行时都需要即时解释转换。
  * 代码保护性较差，源代码容易被查看和修改。
* **常见语言**：\
  Python、JavaScript、Ruby、PHP 等。

***

#### **编译型语言**

* **工作原理**：\
  代码在运行之前经过编译器转换成机器码或中间码（如字节码），生成可执行文件或库，再由系统直接运行。
* **优点**：
  * 执行效率较高，因为编译后的代码可以直接在目标机器上运行，不需要再进行逐行解释。
  * 代码优化可以在编译阶段完成，通常能获得更好的性能。
* **缺点**：
  * 开发周期较长，每次修改后需要重新编译，调试可能不如解释性语言灵活。
  * 跨平台支持需要针对不同平台进行编译。
* **常见语言**：\
  C、C++、Go、Rust，Java（编译为字节码，再由虚拟机解释或即时编译）等。\


#### 混合型语言

混合型语言指的是既具备编译型语言的特性，又采用了解释型语言某些机制的语言。这类语言通常将源代码编译成中间代码（例如字节码），然后由虚拟机解释执行或进行即时编译（JIT），从而兼顾了性能和跨平台的优势。

例如：

* **Java**：Java 源代码首先被编译成字节码，然后在 JVM（Java 虚拟机）上运行，JVM 可以对字节码进行即时编译以提升执行速度。
* **C#**：C# 代码编译成中间语言（IL），然后由 .NET CLR（公共语言运行库）执行，也支持 JIT 编译。
* **Python**（部分实现）：一些 Python 实现（例如 PyPy）会对字节码进行即时编译，从而提高执行效率。

***

**总结**

* 解释性语言适合快速开发和原型设计，代码易于调试，但运行效率相对较低。
* 编译型语言则在性能上具有优势，适用于对效率要求较高的应用，但开发周期和调试难度可能会增加

#### AST抽象语法树（Abstract Syntax Tree）

抽象语法树（Abstract Syntax Tree，简称 AST）是源代码语法结构的一种抽象表示<mark style="color:red;">。它以树状的数据结构形式呈现代码的语法结构</mark>，树中的每个节点都代表着源代码中的一个语法元素。

作用：

* **解析和验证**：通过解析源代码，将其转换为AST之后，可以对代码进行验证和静态分析。这包括检查语法错误、类型错误、变量引用等，并发现潜在的问题或优化机会。
* **优化和转换**：AST可以用于执行各种优化操作，例如消除冗余代码、提取共享表达式、内联函数调用等。它还能够进行代码转换，例如将ES6代码转换为ES5兼容的代码、将模板编译为渲染函数等。
* **生成代码**：从AST中可以再次生成目标代码，如JavaScript、HTML、CSS等。这使得可以将源代码翻译为其他语言、在不同平台上执行代码等。



### **事件驱动**

* **概念**：\
  程序的执行由外部事件触发，如用户操作、网络请求、系统事件等。
* **特点**：
  * 非阻塞、异步执行
  * 响应迅速，解耦生产者与消费者
* **应用场景**：
  * 用户界面交互（点击、拖拽）
  * 网络服务器（处理请求）
  * 物联网设备和游戏开发
*   **示例**：

    ```javascript
    document.getElementById('myButton').addEventListener('click', function() {
      console.log('Button clicked!');
    });
    ```

***

### **数据驱动**

* **概念**：\
  程序的执行逻辑基于数据状态和数据变化，而非外部事件。
* **特点**：
  * 基于数据状态、逻辑可预测
  * 灵活，通过修改数据改变行为
  * 适合批量处理数据
* **应用场景**：
  * 数据分析、报告生成
  * 配置管理
  * 机器学习模型训练与预测
*   **示例**（Python 示例）：

    ```python
    data = [
        {'name': 'Alice', 'age': 30},
        {'name': 'Bob', 'age': 25},
        {'name': 'Charlie', 'age': 35}
    ]

    def process_data(data):
        for person in data:
            if person['age'] > 30:
                print(f"{person['name']} is over 30 years old.")

    process_data(data)
    ```

***

**区别与结合使用**

* **触发方式**：\
  事件驱动：由外部事件触发；\
  数据驱动：由数据状态变化决定执行逻辑。
* **执行模式**：\
  事件驱动通常是异步的；\
  数据驱动通常按数据逻辑顺序同步执行。
* **应用侧重点**：\
  事件驱动适合需要快速响应外部操作的场景；\
  数据驱动适合根据数据做出决策的场景。
* **结合使用**：\
  在实际应用中，常常将两者结合。例如，Web 前端采用事件驱动响应用户操作，而后台数据处理则采用数据驱动模型处理数据。



### **时间复杂度**

时间复杂度并非指程序实际运行的时间，而是算法中执行语句的次数。随着问题规模 n 增大，算法的时间复杂度也会增大，表示算法所花费的“相对时间”越多。

#### 常见的时间复杂度

* 常数阶：**O(1)**
* 对数阶：**O(log₂ n)**
* 线性阶：**O(n)**
* 线性对数阶：**O(n log₂ n)**
* 平方阶：**O(n²)**
* 立方阶：**O(n³)**
* k 次方阶：**O(n^K)**
* 指数阶：**O(2^n)**

#### 计算方法

* 选取增长率最高的项；
* 将最高项的系数忽略（化为 1）；
* 如果算法运行时间不随 n 增加而变化，则用 **O(1)** 表示。

**举例**\
对于函数 f(n) = 3\*n⁴ + 3n + 300，其时间复杂度为 **O(n⁴)**。

#### 注意事项

*   **常数时间算法**\
    如果算法中的执行语句数量固定，不随 n 变化（例如执行 100 次），则时间复杂度为 **O(1)**。

    ```javascript
    let x = 1;
    while (x < 100) { 
      x++; 
    }
    ```
*   **嵌套循环**\
    当存在多个嵌套循环时，时间复杂度由最内层循环决定。例如：

    ```javascript
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        // ...code
      }
    }
    ```

    这段代码的时间复杂度为 **O(n²)**。
*   **循环判断条件**\
    循环次数不仅受 n 的影响，还取决于循环条件。

    ```javascript
    for (var i = 0; i < n && arr[i] !== 1; i++) {
      // ...code
    }
    ```

    如果 `arr[i]` 不等于 1，则循环执行 n 次（**O(n)**）；如果等于 1，则循环可能提前退出。

***

### **空间复杂度**

空间复杂度衡量算法在运行过程中临时占用存储空间的大小。计算时通常忽略常数，只关注随 n 变化的部分。

#### 计算方法

* 忽略常数，用 **O(1)** 表示；
* 对于递归算法，空间复杂度等于“递归深度 × 每次递归使用的辅助空间”。

**举例**\
仅复制单个变量时，空间复杂度为 **O(1)**：

```javascript
let a = 1;
let b = 2;
let c = 3;
console.log('输出a, b, c', a, b, c);
```

对于递归函数，每次调用创建一个局部变量 k，调用 n 次，则空间复杂度为 **O(n)**：

```javascript
function fun(n) {
  let k = 10;
  if (n === k) {
    return n;
  } else {
    return fun(++n);
  }
}
```

### 实时编译（Just-In-Time Compilation, JIT）和预编译（Ahead-Of-Time Compilation, AOT）

是两种不同的编译策略，它们在程序的生命周期中执行的时间点不同，并且各有优缺点。以下是这两种编译方式的区别：

#### 实时编译（JIT）

**定义：** 即时编译是一种特殊的动态编译技术，在程序运行时将字节码（或中间代码）转换成机器码，以提高程序的执行效率。JIT 编译通常在虚拟机中实现。

**工作原理：** JIT 编译器在程序执行时监控代码执行情况，识别出热点代码（即频繁执行的代码片段），并将这些热点代码编译为机器码，从而加速执行。

**优点：**

* 高效的执行性能：利用运行时信息进行深度优化，显著提升程序性能。
* 即时响应：能够快速响应不同的运行环境和输入，提供灵活性。
* 降低延迟：减少频繁解释带来的开销。

**缺点：**

* 编译开销：运行时编译需要一定的计算资源，可能影响程序响应时间。
* 复杂性高：实现高效的 JIT 编译器需要复杂的技术。

**应用场景：** JIT 编译广泛应用于需要高性能的虚拟机环境中，如 Java 虚拟机中的 HotSpot、.NET 中的 CLR，以及 JavaScript 引擎（如 V8）。

#### 预编译（AOT）

**定义：** 预编译是在程序运行之前将源代码或中间代码编译成目标机器码的技术。预编译在程序运行之前完成所有的编译工作，生成可执行文件或库文件。

**工作原理：** 预编译的流程包括解析源代码或字节码、生成中间表示、进行优化、生成机器码并打包成可执行文件。预编译通常用于从字节码到机器码的转换。

**优点：**

* 启动速度快：程序已编译成机器码，加载后即可执行，无需运行时编译。
* 性能稳定：预编译后的程序性能稳定，不会因运行时编译而波动。
* 资源占用少：减少了运行时的编译开销，降低了 CPU 和内存的占用。
* 提前检测错误：在开发阶段或部署阶段检测出编译错误，减少运行时错误。

**缺点：**

* 缺乏运行时优化：无法利用运行时信息进行优化，可能性能不如 JIT。
* 平台依赖性强：生成的机器码针对特定平台，跨平台部署需要重新编译。
* 编译时间长：编译时间可能较长，特别是大型项目。

**应用场景：** 预编译主要用于对启动速度要求高、运行环境稳定的场景，如移动应用、嵌入式系统和前端框架（如 Angular）。

#### 对比总结

| 特性       | JIT 编译          | AOT 编译             |
| -------- | --------------- | ------------------ |
| **编译时机** | 运行时             | 编译期                |
| **性能优化** | 基于实际运行情况进行优化    | 缺乏运行时信息，但可以做更多静态分析 |
| **启动时间** | 较慢，因为需要先编译再执行   | 快速，已经编译完成          |
| **资源消耗** | 可能较高，因为要分配给编译任务 | 较低，因为没有额外的编译开销     |
| **适用场景** | 动态性和灵活性高的环境     | 稳定性要求高的环境          |

理解这些区别有助于开发者根据项目的具体需求选择合适的编译策略。例如，对于需要快速迭代和高度动态的应用，JIT 可能是一个更好的选择；而对于那些对启动时间和稳定性有严格要求的应用，AOT 则可能是更合适的选择。
